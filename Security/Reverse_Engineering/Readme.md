# 리버스 엔지니어링 (Reverse Engineering) ⚙
> 줄여서 리버싱으로도 불리는 리버스 엔지니어링은 무언가 설계하고 제작하는 엔지니어링의 과정을 정반대로 수행하는 것이다. 컴퓨터 프로그래밍적 관점에서는 개발자가 소스 코드를 작성하고, 컴파일한 산출물에서부터 시작하는 것이다. 프로그램의 동작을 직접 실행 시켜보면서 소스 코드의 내용을 추측하는 것도 가능한 방법이고, 컴파일된 결과물의 데이터를 분석하여 소스 코드의 내용을 유추, 복구 해볼 수도 있다. 여기서 언급한 산출물은 프로그램 혹은 이진파일이라고 부른다. 컴파일 되지 않은 코드 역시 '프로그램'이라고 부르는 경우가 있어 '이진 파일'이 조금 더 보편적으로 사용된다. 이진 파일은 사람이 눈으로 식별하기 어려운 데이터로 이루어져 있어, 단순히 이 데이터 값을 본다고 해서 어떤 동작을 하는지 알아내기가 어렵다. 이를 도와주는 것이 '디스어셈블러(disassembler)', '디컴파일러(decompiler)'와 같은 도구이다.

<br>
<br>
<br>

## 레지스터와 메모리의 차이
> 레지스터는 CPU에서 직접 액세스할 수 있는 작은 단위의 데이터를 저장하는 데 사용되며 계산 중에 빠른 액세스를 제공한다. 반면 메모리는 레지스터에 맞지 않는 데이터와 명령을 저장하기 위해 더 큰 공간을 제공하지만 레지스터에 비해 액세스 시간이 느리다.
<br>

- 예를 들어 레지스터는 덧셈 연산에서 더할 두 개의 숫자를 저장하거나, 조건문에서 비교할 두 값을 저장하는 데 사용될 수 있고 메모리는 프로그램의 명령어나 데이터, 또는 사용자가 입력한 정보 등을 저장하는 데 사용된다.
    - 사용자가 2와 3을 입력했고 그걸 더하는 로직이 있다고 할 때 2와 3이란 값은 메모리에 저장되어있다가 덧셈연산이 수행될때 레지스터에 로드되어 연산을 수행한다.



<br>
<br>
<br>

## 기계어/어셈블리어
> 컴퓨터에게 명령을 내리려면 컴퓨터 언어인 기계가 필요하다. 하지만 기계어는 0과 1로 이루어져 사람이 이해하기 어려워 이를 사람이 이용하는 것은 비효율적이였다. 그래서 사람이 이해하기 쉬운 어셈블리어가 탄생하였고 이를 기계어로 번역해주는 어셈블러가 생겨났다. 어셈블리어는 기계어에 비하면 효율적이지만 여전히 규모가 큰 프로그램에서는 부족했다. 그래서 C,C++,Go,java 등의 더욱 사람이 이해하기 쉬운 언어를 만들었고 이를 기계어로 번역해주는 것을 컴파일러라고 한다.

    고급 언어(High-Level Language) : 사람이 이해하기 쉬운 언어로 C,C++,Go,java 같은 언어가 포함된다.
    저급 언어(Low-Level Language) : 사람이 이해하기 어려운 언어로 어셈블리어, 기계어가 포함된다.

> Python, Javascript는 고급 언어이지만 컴파일을 필요로 하지 않는다. 이 언어들은 사용자의 입력, 또는 사용자가 작성한 스크립트를 그때 그때 번역하여 CPU에 전달한다. 이 동작이 통역과 비슷하기 때문에 인터프리팅(Interpreting)이라고 불리며, 마찬가지로 이를 처리해주는 프로그램을 인터프리터(Interpreter)라고 한다.



<br>
<br>
<br>

## 프로그램 / 바이너리(Binary)
> 프로그램(Program)은 연산 장치가 수행해야 하는 동작을 정의한 일종의 문서이다.  프로그램을 연산 장치에 전달하면, CPU는 적혀있는 명령들을 처리하여 프로그래머가 의도한 동작을 수행한다. 사용자가 정의한 프로그램을 해석하여 명령어를 처리할 수 있는 연산 장치를 programmable하다고 하는데, 현대의 컴퓨터가 대표적인 programmable 연산 장치이고, 일반 계산기는 대표적인 non-programmable 연산 장치이다.

 - 소프트웨어 개발자, 해커 등 많은 정보 분야의 엔지니어들이 프로그램을 바이너리(Binary)라고 부르곤 하는데, 이는 Stored-Program Computer에서 프로그램이 저장 장치에 이진(Binary) 형태로 저장되기 때문이다.

<br>
<br>
<br>

 ## 컴파일 과정
 > C언어로 작성된 코드는 일반적으로 전처리(Preprocess), 컴파일(Compile), 어셈블(Assemble), 링크(Link)의 과정을 거쳐 바이너리로 번역된다.

<br>

- 간단한 c 컴파일 과정을 확인해보자
```c
// example.c 초기상태
#include <stdio.h>

int main() {
  printf("hello\n");
  return 0;
}
```

1. 전처리 : 컴파일러가 소스 코드를 어셈블리어로 컴파일하기 전에, 필요한 형식으로 가공하는 과정이다.
    ``` 
    1. 주석 제거
    주석은 개발자가 자신과 개발자들의 코드 이해를 돕기위해 작성하는 메모이다. 주석은 프로그램의 동작과 상관이 없으므로 전처리 단계에서 모두 제거된다.

    2. 매크로 치환
    #define으로 정의한 매크로는 자주 쓰이는 코드나 상숫값을 단어로 정의한 것입니다. 전처리 과정에서 매크로의 이름은 값으로 치환된다.

    3. 파일 병합
    일반적인 프로그램은 여러 개의 소스와 헤더 파일로 이루어져 있다. 컴파일러는 이를 따로 컴파일해 합치기도 하지만, 어떠한 경우는 전처리 단계에서 파일을 합치고 컴파일하기도 한다.
    ```
``` c
// gcc -E example.c > example.i
// 전처리 후 
// stdio.h 전처리 부분은 생략
# 1 "example.c" // "example.c" 파일 시작 지점
int main() {
printf("hello\n"); // printf 함수 호출
return 0; // main 함수 종료
}
```

<br>

2. 컴파일 : 컴파일(Compile)은 C로 작성된 소스 코드를 어셈블리어로 번역하는 것이다. 이 과정에서 컴파일러는 소스 코드의 문법을 검사하는데, 코드에 문법적 오류가 있다면 컴파일을 멈추고 에러를 출력한다.
    - 컴파일러는 코드를 번역할 때, 몇몇 조건을 만족하면 최적화 기술을 적용하여 효율적인 어셈블리 코드를 생성준다.  gcc에서는 -O -O0 -O1 -O2 -O3 -Os -Ofast -Og 등의 옵션을 사용하여 최적화를 적용할 수 있다.
``` assembly
// gcc -S example.i -o example.S
// 컴파일 후 example.s
       .file   "example.c"         // "example.c" 파일 정보
        .section        .rodata      // 읽기 전용 데이터 섹션
.LC0:
        .string "hello"              // "hello" 문자열 정의
        .text                        // 코드 섹션 시작
        .globl  main                 // main 함수 전역 선언
        .type   main, @function      // main 함수 타입 정의
main:
        push    rbp                  // 현재 스택 프레임의 기준점 저장
        mov     rbp, rsp             // 스택 프레임 설정
        lea     rdi, .LC0            // "hello" 문자열의 주소를 rdi 레지스터에 로드
        call    puts                 // puts 함수 호출하여 "hello" 출력
        mov     eax, 0               // 반환 값 0을 eax 레지스터에 저장
        pop     rbp                  // 스택 프레임 복원
        ret                          // 함수 종료 및 반환
        .ident  "GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0"  // 컴파일러 정보
        .section        .note.GNU-stack,"",@progbits           // 스택 보호 정보
```

<br>

3. 어셈블 : 어셈블(Assemble)은 컴파일로 생성된 어셈블리어 코드를 ELF형식의 목적 파일(Object file)로 변환하는 과정이다. 여기서 ELF는 리눅스의 실행파일 형식입니다. 윈도우에서 어셈블한다면 목적 파일은 PE형식을 갖게 된다.
    - 목적 파일로 변환되고 나면 어셈블리 코드가 기계어로 번역되므로 더이상 사람이 해석하기 어려워진다.
    - gcc -c example.S -o example.o

<br>

4. 링크 : 링크(Link)는 여러 목적 파일들을 연결하여 실행 가능한 바이너리로 만드는 과정이다. 링크를 거치고 나면 실행할 수 있는 프로그램이 완성된다.
    - 예를 들어 printf 함수의 정의는 example.c에 없고 libc라는 공유 라이브러리에 존재한다. libc는 gcc의 기본 라이브러리 경로에 있는데, 링커는 바이너리가 printf를 호출하면 libc의 함수가 실행될 수 있도록 연결해준다.
    - gcc example.o -o example -Xlinker --unresolved-symbols=ignore-in-object-files


<br>
<br>
<br>

## 디스어셈블
> 바이너리를 분석하려면 바이너리를 읽을 수 있어야 한다. 그런데 컴파일된 프로그램의 코드는 기계어로 작성되어 있으므로 이를 그 자체로 이해하기는 매우 어렵다. 그래서 분석가들은 이를 어셈블리어로 재번역하고자 하였다. 이 과정은 앞서 살펴본 어셈블의 역과정이므로 디스어셈블(Disassemble)이라고 부른다.

- 리눅스에서는 `objdump -d ./example -M intel` 를 통해 디스어셈블된 결과를 확인할 수 있다.

<br>
<br>
<br>

## 디컴파일
> 디스어셈블 기술의 등장으로 예전보다는 바이너리를 분석하기 쉬워졌지만, 여전히 규모가 큰 바이너리의 동작을 어셈블리 코드만으로 이해하기는 어려웠다. 그래서 리버스 엔지니어들은 어셈블리어보다 고급 언어로 바이너리를 번역하는 디컴파일러(Decompiler)를 개발하였다. 그런데 어셈블리어와 기계어는 거의 일대일로 대응되어서 오차없는 디스어셈블러를 개발할 수 있었지만, 고급 언어와 어셈블리어 사이에는 이런 대응 관계가 없습니다. 또한, 코드를 작성할 때 사용했던 변수나 함수의 이름 등은 컴파일 과정에서 전부 사라지고, 코드의 일부분은 최적화와 같은 이유로 컴파일러에 의해 완전히 변형되기도 한다. Hex Rays, Ghidra를 비롯한 뛰어난 디컴파일러들이 있다.

<br>
<br>
<br>

## 정적 분석(Static Analysis) / 동적 분석(Dynamic Analysis)
> 정적 분석은 외적인 관찰만을 통해 정보를 알아내는 것이고, 동적 분석은 직접 실행을 해보며 동작을 분석하는 것이다. 동적인 방법만을 고수하면 큰 구조를 놓칠 수 있고, 반대로 정적인 방법만을 고수하면 실행을 통해 직관적으로 알 수 있는 부분을 분석하느라 시간을 허비할 수 있다. 정적인 방법과 동적인 방법을 적절히 혼용하여야 대상을 효과적으로 분석할 수 있다.

<br>

- 정적 분석의 장단점
```
장점

1. 전체 구조를 파악하기 쉽다.

2. 분석 환경의 제약에서 비교적 자유롭다.

3. 바이러스와 같은 악성 프로그램의 위협으로부터 안전하다.


단점

1. 난독화가 적용되면 분석이 어려워진다.

2. 다양한 동적 요소를 고려하기 어렵다.
```

<br>

- 동적 분석의 장단점
```
장점

1. 코드를 자세히 분석해보지 않고도 프로그램의 개략적인 동작을 파악할 수 있다.


단점

1. 분석 환경을 구축하기 어려울 수 있다.

2. 동적 분석의 일종인 디버깅을 방해하는 안티 디버깅(Anti Debugging)이 적용되면 분석이 어렵다. 자신이 디버깅 당하고 있는지 검사하고, 디버깅 중이면 프로그램을 강제로 종료시키는 방법이 있다.
```




<br>
<br>
<br>


## 주의
```
관련 저작권법⚖️

저작권법 제35조의3 (저작물의 공정한 이용) 제1항 제23조부터 제35조의2까지, 제101조의3부터 제101조의5까지의 경우 외에 저작물의 통상적인 이용 방법과 충돌하지 아니하고 저작자의 정당한 이익을 부당하게 해치지 아니하는 경우에는 보도ㆍ비평ㆍ교육ㆍ연구 등을 위하여 저작물을 이용할 수 있다.

저작권법 제101조의3 (프로그램의 저작재산권의 제한) 제1항 제6호 프로그램의 기초를 이루는 아이디어 및 원리를 확인하기 위하여 프로그램의 기능을 조사ㆍ연구ㆍ시험할 목적으로 복제하는 경우(정당한 권한에 의하여 프로그램을 이용하는 자가 해당 프로그램을 이용 중인 때에 한한다)
```