# 알고리즘 공부하며 배운 내용 
<br>
<br>
<br>

### 연결 리스트
- 연속된 노드의 연결체, 노드란 연결리스트에서 사용되는 하나의 데이터 덩어리이며 데이터와 next(pointer) 2가지 필드를 담고 있다
    - data : 노드가 담고 있는 값
    - next : 다음 노드의 주소를 저장    
- 물리적 메모리 주소가 연속적으로 나타나는 배열과 달리 연결리스트는 연속적이지 않고 랜덤이다.

<br>

### 바인딩
- 값을 할당하는 과정

<br>

### 네임스페이스
- 네임스페이스는 이름 충돌을 방지하는 방식으로 식별자를 구성하고 사용할 수 있도록 하는 식별자(예: 변수 이름) 집합이다.
- 프로그래밍을 하다보면 비슷한 의미를 가져 충돌되는 이름이 생길수 있다. 따라서 네임스페이스라는 공간의 분리를 통해 서로 다른 네임스페이스(서로 다른 모듈)에 있다면 같은 이름이 있어도
충돌하지 않는다
- 네임스페이스의 종류
    + 전역 네임스페이스: 모듈별로 존재하며, 모듈 전체에서 통용될 수 있는 이름들이 소속된다. `globals()` 를 통해 확인할 수 있다.
    + 지역 네임스페이스: 함수 및 메서드 별로 존재하며, 함수 내의 지역 변수들의 이름들이 소속된다. `locals()` 를 통해 확인할 수 있다.
    + 빌트인 네임스페이스: 기본 내장 함수 및 기본 예외들의 이름들이 소속된다. 파이썬으로 작성된 모든 코드 범위가 포함된다. `dir(__builtins__)` 를 통해 확인할 수 있다.
    - 우선순위는 빌트인 > 전역 > 지역 순이다.
- 클래스 함수 내부의 필드나 메서드는 '.'을 찍는 방식으로 네임스페이스를 표시하여 접근할 수 있지만, 일반 함수는 그 자체의 네임스페이스를 가짐에도 불구하고 그렇게 접근할 수 없다

``` python
    hi='hi' #전역 변수이자 전역네임스페이스에 존재한다
    print('global: '+str(globals()))

    def hi():
        hi='hello~' #지역 변수이자 지역네임스페이스에 존재한다
        print('local: '+ str(locals()))
    hi()

    str="hehe~"
    print(str) # 빌트인 함수인 str을 사용하려하면 에러가 난다.
```


<br>

### 객체와 인스턴스의 차이
  - 클래스에 의해서 만들어진 객체를 인스턴스라고도 한다.
  - a를 단독으로 지칭할 때:  'a는 객체' 
  - 클래스와 연관지어서 지칭할때: 'a는 Cookie의 인스턴스' 

  ``` python
    class Cookie:
        pass

    a = Cookie() # a는 객체이며 a는 Cookie의 인스턴스이다.
    ```
<br>

###  __init__ 메서드
- 인스턴스가 호출될때 자동으로 호출되는 특수 메서드

<br>

### 집합자료형
- 집합을 쉽게 처리하기 위해 만든 자료형
- 중복을 허용하지 않고 순서가 없다.
``` python
    s2 = set("Hello")
    print(s2)
    # {'e', 'H', 'l', 'o'}
```

<br>

### 슬라이딩 윈도우 알고리즘
- 부분 문자열에 중복문자가 없다면 종료포인터를 앞으로 움직여 부분문자열을 늘린다.
- 부분 문자열에 중복문자가 있다면 시작포인터를 앞으로 움직여 부분문자열을 줄린다.
``` python
"""
    ↓ 시작 포인터(세트에서 제거할 문자를 가르킴)
    aabcbbeacc
     ↑ 종료 포인터(세트에 추가할 문자를 가리킴)
세트 = {a}  (종료포인터가 세트에 있는 문자를 가르킬때는 시작포인터를 앞으로 움직임)
최대길이 = 1
"""
```












### 기타
- leetcode 깃허브 커밋할때 leetcode새버전으로 하면 안될수도 있다. 안되면 구버전으로 바꾸고 다시 제출하기
- 회문 문자열 : 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열 (EX: bed,토마토 )