# 컴퓨터 과학 기초


## 비트와 바이트 (bit/byte)
> 컴퓨터의 데이터를 다루는데 가장 기본이 되는 개념이다. 0과 1만으로 데이터를 표현하고 처리한다. 전기 신호가 통할 때는 1, 아닐때는 0으로 나타낸다. 이때 0과 1을 나타내는 컴퓨터에서 사용하는 데이터의 최소 단위를 1비트라고 한다. 8개의 비트로 구성된 더 큰 단위를 1바이트라고 하고 1바이트는 메모리에 저장되는 최소 단위이다. 1바이트는 2^8=256가지 수를 표현할 수 있다. 10진수로 0 ~ 255, 2진수로 00000000 ~ 11111111, 16진수로 00~FF까지 나타낸다.

- 예를 들어 2진수가 00111100이면 16진수로는 0x3C 10진수로는 60으로 표현된다.

> 이때 이진 데이터로 표현됬을때 가장 왼쪽의 비트를 최상위 비트 MSB, 가장 오른쪽의 비트를 최하위 비트 LSB라고 부른다. 부호가 있는 데이터일 경우 2의 보수와 같은 부호 있는 표현 체계를 이용해서 해석한다. 2의 보수에서 MSB는 부호 비트로 0이면 양수, 1이면 음수이다. 여기서 2의 보수는 컴퓨터가 음수를 표현하기 위해 사용하는 방법이다.

- 17을 2진수로 표현하면 00010001이다. -17을 2의 보수연산을 사용해 2진수로 표현하면 11101111이다.
- 2의 보수 연산: 모든 비트를 반전한다. 비트가 0이면 1로 1이면 0으로 바꿔주고 1을 더해주는 방식이다

<br>
<br>
<br>

## 바이트 오더링 (Byte Ordering)
> 2바이트 이상의 데이터는 메모리에 연속적으로 저장된다. 이때 각 바이트가 메모리에 정렬되는 방식을 바이트 오더링이라고 한다. 두가지 방식으로 빅 엔디안과 리틀 엔디안이 있다. 문자열을 메모리에 저장할 때는 바이트 오더링을 고려하지 않고 문자 순서 그대로 메모리에 저장된다. 문자열이 아닌 데이터는 리틀 엔디안 방식으로 저장된다. 일반적으로 엔디안이라고 하는 바이트 순서 지정은 일반적으로 정수, 부동 소수점 및 포인터와 같은 다중 바이트 데이터 유형을 처리할 때 사용한다.

- 빅 엔디안(Big Endian): 큰 바이트부터 낮은 주소에 저장된다.
- 리틀 엔디안(Little Endian) : 작은 바이트부터 낮은 주소에 저장된다.
- 0x01234567과 같은 데이터가 있을 때, 가장 왼쪽의 0x01이 가장 큰 바이트이고, 가장 오른쪽의 0x67이 가장 작은 바이트이다.
    - 빅 엔디안은 0x01234567 순서로 메모리에 저장하고 리틀 엔디안은 0x67452301 순서로 메모리에 저장한다.

<br>

- 문자열의 경우
| Memory Address | Content |
| -------------- | ------- |
| 0x1000         | 'A' (0x41) |
| 0x1001         | 'B' (0x42) |
| 0x1002         | 'C' (0x43) |
| 0x1003         | 'D' (0x44) |
- 문자열 'A', 'B', 'C', 'D'의 각 문자는 연속된 메모리 주소에 저장된다.
- 각 문자는 1바이트의 메모리를 차지한다.
- 문자는 문자열에 나타나는 순서대로 저장된다.

<br>


- 문자열이 아닌 16진수의 경우
| Memory Address | Content                    |
| -------------- | --------------------------|
| 0x2000         | 0x78 (Least significant byte) |
| 0x2001         | 0x56                      |
| 0x2002         | 0x34                      |
| 0x2003         | 0x12 (Most significant byte) |
- 최하위 바이트 '0x78'은 최하위 메모리 주소 '0x2000'에 저장된다.
- 최상위 바이트 '0x12'는 최상위 메모리 주소 '0x2003'에 저장된다.


<br>
<br>
<br>

## 비트 연산
> 피연산자를 2진수로 표현해 비트 단위로 연산하는 것을 비트 연산이라고 한다. 비트를 특정 값 만큼 이동하는 시프트 연산을 수행한다.

1. 논리 연산
    - x || y : 둘 중 하나라도 참이면 결과는 참이다.
    - x && y : 둘 다 참이면 결과는 참이다.
    - !x : 참이면 결과는 거짓, 거짓이면 결과는 참이다.
<br>

2. 비트 연산자
    - x | y : 두 비트 중 하나라도 1이면 결과는 1이다.
    - x & y : 두 비트 모두 1이면 결과는 1이다.
    - x ^ y : 두 비트가 같으면 결과는 0, 다르면 결과는 1이다.
    - ~x : 비트가 0이면 결과는 1, 1이면 결과는 0으로 모든 비트를 반전시킨다.

3. 시프트 연산자
- x << n : 비트를 n 만큼 왼쪽으로 이동한다. x*2^n
- x >> n : 비트를 n 만큼 오른쪽으로 이동한다. x/2^n
- x >>> n : 비트를 n 만큼 오르쪽으로 이동하고 왼쪽 빈칸은 모두 0으로 채운다. 음수는 부호가 유지되지 않는다.

> 추가로 비트 연산을 활용해 &연산자를 이용한 비트 마스킹, XOR연산을 활용한 비교와 암호화, AND (&) 연산과 시프트 연산을 활용하여 특정 비트/바이트 가져오기, 곱셈과 나눗셈 등이 가능하다.


<br>
<br>
<br>

## 인코딩/디코딩
> 인코딩(Encoding)은 데이터를 특정한 형식으로 변환하는 것을 말한다. 데이터의 크기를 줄이거나, 컴퓨터가 이해하기 쉽게 변환할 때 사용 한다. 인코딩된 데이터는 디코딩(Decoding)하여 원래의 값을 구할 수 있다. 인코딩은 암호화와 유사하지만, 암호화는 데이터의 기밀성을 목적으로 남이 데이터를 알아보지 못하도록 변환하기 때문에 비밀키가 있어야 원문을 복구할 수 있지만, 인코딩은 누구나 표준화된 방식을 사용해서 디코딩하여 원문을 구할 수 있다는 점이 다르다. 인코딩을 암호화랑 착각하면 안된다.


<br>
<br>
<br>

## 아스키코드 
> 아스키 코드(American Standard Code for Information Interchange, ASCII)는 정보 교환을 위한 미국 표준 코드로, 문자를 숫자로 변환하는 문자 인코딩(character encoding)의 표준이다. 아스키 코드를 사용하여 문자를 숫자로 인코딩하면 서로 다른 장치 간 데이터 전송을 더 쉽게 수행할 수 있다. 아스키 문자 1개는 1 바이트 크기로, 7 비트로 문자를 표현하고 1 비트(패리티 비트)는 오류 체크를 위해 사용한다. 2^7=128가지의 문자 표현이 가능하며 각 문자는 0~127까지의 10진수 값을 가진다. 이 값을 아스키 값이라고 한다.

- 패리티 비트는 정보의 전달 과정에서 오류가 생겼는지 검사하는 비트이다. 홀수 패리티와 짝수 패리티 두가지가 있다.
    - 7개의 비트 중 1의 개수가 홀수면 홀수 패리티로 첫번째 비트에 0이 추가된다.
    - 7개의 비트 중 1의 개수가 짝수면 짝수 패리티로 첫번째 비트에 1이 추가된다.
    - 수신 복호기는 7개의 비트를 먼저 확인해 추가된 비트가 앞에 나온 짝수 패티리와 홀수 패리티 처럼 나오지 않는다면 오류가 있다고 판단한다.

<br>
<br>
<br>

## 유니코드
> 유니코드(Unicode)는 영어 뿐만 아니라, 전세계 모든 언어의 문자에 고유한 번호를 부여하는 국제 표준 코드이다. 서로 다른 언어를 사용할 때 문자가 호환되지 않는 문제를 해결하기 위해 만들어 졌다. 아스키 코드보다 용량을 크게 확장하여 최대 32 비트로 문자 1개를 표현하여, 현재 143000개 이상의 문자를 표현할 수 있다. 유니코드의 처음 128개 문자는 아스키 코드의 문자와 일치한다. 유니코드 안에 아스키코드가 포함된다. UTF-8, UTF-16, UTF-32 등 유니코드를 사용하는 다양한 인코딩 형식이 존재한다. UTF 뒤의 숫자는 비트를 의미한다. 현재 컴퓨터로 볼 수 있는 글자는 대부분 UTF-8로 인코딩된 값이다.

<br>
<br>
<br>

## URL 인코딩 (퍼센트 인코딩)
> 웹에서 사용되는 URL은 특정한 형식의 문자열만 허용한다. 알파벳 대소문자, 숫자, 그리고 일부 특수 문자만을 포함할 수 있다. 웹 브라우저로부터 받은 URL 문자열을 유효한 형식으로 변환하는 것을 URL 인코딩이라고 한다. URL 인코딩을 통해 문자열을 인터넷으로 전송 가능한 형식으로 변환한다. 이를 통해 전송 중에 문자가 수정되거나 의도와 다르게 해석되는 것을 막을 수 있다. 허용되지 않는 문자, 즉 인코딩이 필요한 특수문자는 :/?#[]@!$&'()*+,;=%공백이다. URL 인코딩은 % 기호 뒤에 해 문자의 아스키 코드 16진수 값을 붙여 나타냅니다. 공백 문자를 예로 들어 보겠습니다. URL에 공백이 포함되는 경우 + 기호 혹은 %20으로 변환된다.

<br>
<br>
<br>

## base64 인코딩
> base64 인코딩은 이진 데이터를 아스키 문자로 구성된 텍스트로 변환하는 인코딩 방식이다. 총 64개의 아스키 문자가 인코딩에 사용되기 때문에 64진법(Base 64)라는 의미에서 이러한 이름이 붙여졌다. 64개의 아스키 문자는 알파벳 대소문자(52자), 숫자(10자), +, / 이다. base64 인코딩은 이진 데이터를 그대로 포함할 수 없이 텍스트만 허용되는 환경에서 이진 데이터를 텍스트 형식으로 나타내기 위해 사용한다. 예를 들어, 이진 데이터인 이미지를 HTML 파일에 넣는 경우 base64로 인코딩해 넣을 수 있다.

- 인코딩 단계
    1. 원본 이진 데이터를 비트 나열로 표현하고, 이를 6 비트씩 끊어서 묶습니다. 만약 비트의 개수가 6의 배수가 아닐 경우, 0을 뒤에 추가하여 6의 배수로 만든다.
    2. 각 6 비트 묶음을 수로 변환한 뒤, base64 테이블에서 해당하는 문자를 찾아 이로 치환한다.
    3. 치환 과정을 거친 뒤, 글자 수가 4의 배수가 되도록 문자 '='를 반복해 뒤에 추가한다. 이를 패딩(Padding)이라고 한다.
        > 패딩을 넣는 이유 : "ZA" 를 디코딩하면 011001 000000가 나오고 8개씩 끊어서 읽으면 아스키 문자 ‘d' 이후 나머지 0000이 남게 된다. 이 경우 디코딩을 하는 입장에서 뒤에 추가적인 내용이 있는데 오지 않은 것인지, 아니면 여기서 디코딩을 끝내야 되는지 알 수 없기 때문에 =를 붙여 총 비트가 8의 배수가 되게 한다.
 
<br>
<br>
<br>

## 운영체제
> 사용자 및 응용프로그램을 사용할 수 있도록 운영체제가 하드웨어와 사용자, 응용 프로그램 사이에서 관리하는 역할을 한다. 

- 기능
    1. 실행중인 프로그램인 프로세스에 CPU를 할당해야하는데 어떤 프로세스에 CPU를 할당할지 결정한다. (CPU 스케줄링)
    2. 메모리 공간을 각 프로세스에 분배하고 사용하는 과정을 관리한다.
    3. 컴퓨터가 입출력 장치와 정보를 주고 받는 과정을 관리한다.

<br>  

- 커널과 셸 
    - 커널 : 운영체제의 핵심기능인 하드웨어 관리를 실제로 수행하는 프로그램이다. 커널은 소프트웨어와 하드웨어 간의 커뮤니케이션을 관리하며, 시스템이 부팅될 때 메모리에 올라가서 꺼질 때까지 실행된다.
    - 셸 : 사용자와 운영체제의 커널 사이에서 사용자가 명령을 내릴 수 있도록 인터페이스 역할을 한다. 사용자가 셸에 명령어를 입력하면 셸이 그 명령어를 해석해 커널에 요청한다. 널은 명령을 수행하며 하드웨어를 조작하고, 수행 결과를 셸에 전송한다.

<br>

- 운영체제의 종류
    - Windows : 마이크로소프트사에서 개발한 운영체제로, Graphical User Interface (GUI) 기능을 제공하여 사용자가 편리하게 사용할 수 있다. 많으 사람들이 윈도우를 사용해 비교적 친숙하다.
    - UNIX : 벨 연구소에서 개발한 운영체제로, 대부분의 운영체제는 UNIX로부터 발전된 기술을 사용하고 있다. 사용자가 키보드로 입력하는 명령에 의해 조작되는 Character User Interface (CUI) 기반의 대화식 운영체제이다.
    - Linux : UNIX 기반의 운영체제로 소스 코드를 공개하여 누구나 수정하고 재배포할 수 있는 오픈소스 프로그램으로, 많은 사람에 의해 계속해서 발전하고 있다. CUI 기반의 운영체제로 Linux를 기반으로 Ubuntu, CentOS 등의 다양한 버전이 존재한다.
    - 기타 : UNIX 기반의 또 다른 운영체제로는 애플에서 개발한 GUI 기반 운영체제 macOS, 스마트폰을 많이 사용하는 현대인에게 친숙한 모바일 운영체제 Android와 iOS가 있다.


 
<br>
<br>
<br>

## 정규표현식
> 정규 표현식(Regular Expression)은 특정한 패턴으로 문자열을 표현하는 식이다. 일반적으로 문자열 내에서 원하는 패턴의 문자열을 찾거나 치환할 때 사용한다. 여기서 ‘패턴’은 어떤 문자 조합을 식으로 나타낸 것을 의미한다.  정규 표현식에 부합하는 문자열의 경우, 정규 표현식 혹은 패턴에 ‘매치한다’고 표현한다.

<br>

- 이메일 정규 표현식 예시 : `^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$`
    - `xxx@xxx.xxx` 정규 표현식에 매치한다.
    - `xxx@xxx.x` 정규 표현식에 매치하지 않는다.

<br>


### 사용하는 이유
>  정규 표현식은 주로 로직을 수행하기 전에 이용자가 입력한 값을 검증하기 위해 사용한다. 이메일 정규 표현식 예시 처럼 이메일 정규 표현식에 매치하는지 확인하였는데, 이를 활용하면 이용자가 알맞은 형식의 이메일을 입력했는지 검증할 수 있다. 이메일 뿐만 아니라 전화번호, 주민등록번호, 웹사이트 주소 등 입력 값이 특정 형식이어야 하는 모든 경우에 유용하게 쓰인다.

<br>

### 정규 표현식의 구성
> 정규 표현식은 '패턴' 혹은 /패턴/ 의 형태로 작성한다. /로 패턴을 감싸는 경우, / 뒤에 플래그를 작성할 수 있다.
> 기본적으로 정규 표현식의 수량자는 탐욕적(greedy) 수량자에 속한다. 탐욕적 수량자는 이름 그대로, 가능한 많은 문자를 매치합니다. 다르게 말하면 패턴에 더 이상 매치하지 않을 때까지 모두 매치하는 문자열로 인식한다. 탐욕적 수량자로 인한 과한 매치를 막기 위해 등장한 것이 게으른(lazy) 수량자이다. 게으른 수량자는 기존 수량자의 뒤에 ?를 붙인 형태로, 가능한 적은 문자를 매치한다. <.*> 패턴을 예로 들면 해당 패턴을 <p>Hi!</p> 라는 문자열에 매치하면 *는 탐욕적 수량자이므로 모든 문자열 <p>Hi!</p>가 패턴에 매치한다. <.*?> 패턴에서 *?는 게으른 수량자이므로 최소한의 문자만 매치한다. 따라서 전체 문자열이 아닌 <p>와 </p>가 패턴에 매치한다.

<br>

- 매칭

| 패턴      | 설명                                      | 예제               | 매치             |
|----------|------------------------------------------|--------------------|---------------------------|
| 문자 또는 문자열 | 해당 문자 또는 문자열과 일치합니다. | dreamhack → hello dreamhack | hello dreamhack       |
| /c/      | 문자 'c'와 일치합니다.                   | d.eamhack → Hello dxeamhack | Hello dxeamhack       |
| .        | 아무 문자와 일치합니다.                   | d.eamhack → Hello dxeamhack | dxeamhack             |
| \|       | 앞 또는 뒤에 패턴을 일치시킵니다.       | hi\|dream → Hello dreamhack | Hello dreamhack       |
| [ ]      | [ ] 내의 문자와 일치합니다.              | [aeiou] → Hi       | H                       |
| [^ ]     | ^ 다음에 오는 패턴을 제외한 모든 것과 일치합니다. | [^aeiou] → Hi | H                      |
| ^        | 특정 패턴으로 문자열이 시작하는지 여부를 확인합니다. | ^dream → dreamhack Hello | dreamhack Hello       |
| $        | 문자열이 특정 패턴으로 끝나는지 여부를 확인합니다. | hack$ → dreamhack Hello | dreamhack Hello       |
| \        | 특수 문자 뒤에 특수 문자를 일치시킵니다. | hack\$ → Hello dreamhack$ | Hello dreamhack$     |
| [a-z]    | 두 문자 사이의 문자와 일치합니다.        | [b-d] → hack      | hack                    |
| [A-Z]    | 두 문자 사이의 문자와 일치합니다.        | [b-d] → hack      | hack                    |
| [0-9]    | 두 문자 사이의 문자와 일치합니다.        | \d → a1           | 1                       |
| \w       | 알파벳 또는 숫자 또는 _와 일치합니다.   | \w → a!           | a                       |
| \d       | 숫자와 일치합니다.                       | \d → a1           | 1                       |
| \s       | 공백 문자와 일치합니다.                  | \s → Hello dreamhack |  

<br>

- 수량자
| 패턴      | 설명                                                          | 예제                       | 매치         |
|------------|---------------------------------------------------------------|----------------------------|--------------|
| *         | 0개 이상의 앞선 문자가 있으면 매치됩니다.                      | Hac*k → Hak               | Hak, Hack    |
| +         | 1개 이상의 앞선 문자가 있으면 매치됩니다.                      | Hac+k → Hak               | Hak, Hack    |
| ?         | 앞선 문자가 0개 또는 1개인 경우에 매치됩니다.                 | Hac?k → Hak               | Hak, Hack    |
| Quantifier? | 앞선 양자자에 ?를 추가하면 최소한의 수의 문자와 일치합니다.  | <p>.*</p> → <p>Hello</p><p>Hi</p> | <p>Hello</p>, <p>Hi</p> |
| {n}       | 정확히 n개의 앞선 문자가 있는 경우에 매치됩니다.             | Hac{3}k → Haccck          | Haccck       |
| {n,}      | n개 이상의 앞선 문자가 있는 경우에 매치됩니다.               | Hac{2,}k → Haccck         | Haccck       |
| {n1, n2}  | n1개 초과 n2개 미만의 문자가 있는 경우에 매치됩니다.        | Hac{2,3}k → Hacck         | Hacck        |

<br>

-  그룹화
| 패턴      | 설명                                                  | 예제                   | 매치          |
|------------|-------------------------------------------------------|------------------------|---------------|
| ( )        | 괄호 안에 포함된 부분은 하나의 문자로 처리됩니다.       | (ha)+ck → hahahack    | hahahack      |
이렇게 하면 Markdown 문서에 패턴, 설명, 예제 및 해당 매치가 포함된 표가 나타납니다. 이것을 복사하여

<br>

### 정규 표현식 플래그
> 정규 표현식의 플래그는 검색의 옵션을 지정하는 역할을 한다. 일반적으로 /패턴/플래그 형식으로 작성한다.
<br>

| 패턴      | 설명                                                        | 예제                     | 매치         |
|------------|-------------------------------------------------------------|--------------------------|--------------|
| g          | 전역 검색                                                    | /[aeiou]/ → Hello dreamhack | a, e, o | u |
|            |                                                             | /[aeiou]/g → Hello dreamhack | e, o, e, a |
| i          | 대소문자를 구분하지 않고 검색합니다.                        | /h/g → Hello dreamhack    | h, h       |
|            |                                                             | /h/ig → Hello dreamhack   | h, H, h    |
| m          | 여러 줄에 걸쳐 검색합니다.                                   | /^Hello/g → Hello dream   | Hello       |
|            |                                                             | Hello hack                |              |
|            |                                                             | /^Hello/gm → Hello dream  | Hello       |
|            |                                                             | Hello hack                |              |
| s          | 단일 행(dotall)                                               | /Hello.+hack/g → Hello dream | Hello hack |
|            |                                                             | /Hello.+hack/s → Hello dream | Hello dream<br/>Hello hack |


<br>
<br>
<br>


##### 드림핵 공부 내용