# 알고리즘 공부하며 배운 내용 
<br>
<br>
<br>

## 연결 리스트
- 연속된 노드의 연결체, 노드란 연결리스트에서 사용되는 하나의 데이터 덩어리이며 데이터와 next(pointer) 2가지 필드를 담고 있다
    - data : 노드가 담고 있는 값
    - next : 다음 노드의 주소를 저장    
- 물리적 메모리 주소가 연속적으로 나타나는 배열과 달리 연결리스트는 연속적이지 않고 랜덤이다.

<br>
<br>
<br>

## 바인딩
- 값을 할당하는 과정

<br>
<br>
<br>

## 네임스페이스
- 네임스페이스는 이름 충돌을 방지하는 방식으로 식별자를 구성하고 사용할 수 있도록 하는 식별자(예: 변수 이름) 집합이다.
- 프로그래밍을 하다보면 비슷한 의미를 가져 충돌되는 이름이 생길수 있다. 따라서 네임스페이스라는 공간의 분리를 통해 서로 다른 네임스페이스(서로 다른 모듈)에 있다면 같은 이름이 있어도
충돌하지 않는다
- 네임스페이스의 종류
    + 전역 네임스페이스: 모듈별로 존재하며, 모듈 전체에서 통용될 수 있는 이름들이 소속된다. `globals()` 를 통해 확인할 수 있다.
    + 지역 네임스페이스: 함수 및 메서드 별로 존재하며, 함수 내의 지역 변수들의 이름들이 소속된다. `locals()` 를 통해 확인할 수 있다.
    + 빌트인 네임스페이스: 기본 내장 함수 및 기본 예외들의 이름들이 소속된다. 파이썬으로 작성된 모든 코드 범위가 포함된다. `dir(__builtins__)` 를 통해 확인할 수 있다.
    - 우선순위는 빌트인 > 전역 > 지역 순이다.
- 클래스 함수 내부의 필드나 메서드는 '.'을 찍는 방식으로 네임스페이스를 표시하여 접근할 수 있지만, 일반 함수는 그 자체의 네임스페이스를 가짐에도 불구하고 그렇게 접근할 수 없다

``` python
    hi='hi' #전역 변수이자 전역네임스페이스에 존재한다
    print('global: '+str(globals()))

    def hi():
        hi='hello~' #지역 변수이자 지역네임스페이스에 존재한다
        print('local: '+ str(locals()))
    hi()

    str="hehe~"
    print(str) # 빌트인 함수인 str을 사용하려하면 에러가 난다.
```


<br>
<br>
<br>

## 객체와 인스턴스의 차이
  - 클래스에 의해서 만들어진 객체를 인스턴스라고도 한다.
  - a를 단독으로 지칭할 때:  'a는 객체' 
  - 클래스와 연관지어서 지칭할때: 'a는 Cookie의 인스턴스' 

  ``` python
    class Cookie:
        pass

    a = Cookie() # a는 객체이며 a는 Cookie의 인스턴스이다.
    ```
<br>

##  __init__ 메서드
- 인스턴스가 호출될때 자동으로 호출되는 특수 메서드

<br>
<br>
<br>

## 집합자료형
- 집합을 쉽게 처리하기 위해 만든 자료형
- 중복을 허용하지 않고 순서가 없다.
``` python
    s2 = set("Hello")
    print(s2)
    # {'e', 'H', 'l', 'o'}
```

<br>
<br>
<br>

## 슬라이딩 윈도우 알고리즘
- 부분 문자열에 중복문자가 없다면 종료포인터를 앞으로 움직여 부분문자열을 늘린다.
- 부분 문자열에 중복문자가 있다면 시작포인터를 앞으로 움직여 부분문자열을 줄린다.
``` python
"""
    ↓ 시작 포인터(세트에서 제거할 문자를 가르킴)
    aabcbbeacc
     ↑ 종료 포인터(세트에 추가할 문자를 가리킴)
세트 = {a}  (종료포인터가 세트에 있는 문자를 가르킬때는 시작포인터를 앞으로 움직임)
최대길이 = 1
"""
```
<br>
<br>
<br>

## DFS/BFS
- DFS(깊이우선탐색) : 한가지의 길로 최대한 깊이 탐색한후 더 깊이 갈 곳이 없을 경우 역추적(다른분기로 이동)하여 탐색한다.
    - 모든 노드를 방문하려 할때 사용한다.
    -  DFS에서 재귀 호출이 너무 깊어져 호출 스택이 과도하게 커져 시스템이 스택 공간을 모두 사용하게 되는 스택 오버플로우를 조심해야 한다.
    - 스택 데이터 구조를 통해 수행한다. 후입선출(LIFO) 방식
- BFS(너비우선탐색) : 루트 혹은 임의의 노드에서 시작하여 이웃노드로 이동하기전에 모든 이웃을 탐색한다. 가까운 노드부터 멀리있는 노드까지 차례대로 모두 순회하는 방식이다.
    - 두 노드사이의 최단 경로를 찾을때 사용한다.
    - 큐 데이터 구조를 통해 수행한다. 선입선출(FIFO) 방식 선입선출 순서로 노드를 저장하려면 추가 메모리가 필요
-  DFS는 재귀 스택을 사용하므로 더 적은 메모리가 필요한 반면, BFS는 큐를 사용하므로 더 많은 메모리가 필요할 수 있다
- 
``` python
# 백준 1260번
def dfs(V):
    visited[V] = 1  # 현재 노드를 방문했다고 표시
    print(V, end=' ')  # 현재 노드 출력
    for i in range(1, vertex + 1):
        # 현재 노드와 연결되어 있고, 방문하지 않은 인접 노드를 찾음
        if graph[V][i] == 1 and visited[i] == 0:
            dfs(i)  # 찾은 노드에 대해 재귀적으로 DFS 수행

def bfs(V):
    visited2[V] = 1  # 시작 노드를 방문했다고 표시
    queue = [V]  # 시작 노드를 큐에 넣음
    while queue:
        V = queue.pop(0)  # 큐의 맨 앞에서 노드를 꺼내옴
        print(V, end=' ')  # 현재 노드 출력
        for i in range(1, vertex + 1):
            # 현재 노드와 연결되어 있고, 방문하지 않은 인접 노드를 찾음
            if graph[V][i] == 1 and visited2[i] == 0:
                queue.append(i)  # 찾은 노드를 큐에 넣음
                visited2[i] = 1  # 방문했다고 표시


# 입력 받기
vertex, edge, start = map(int, input().split(' '))
visited = [0] * (vertex + 1)  # DFS를 위한 방문 배열
visited2 = [0] * (vertex + 1)  # BFS를 위한 방문 배열

graph = [[0] * (1 + vertex) for _ in range(1 + vertex)]  # 그래프 표현을 위한 2차원 배열 초기화

# 간선 정보 입력
for i in range(edge):
    a, b = map(int, input().split(' '))
    graph[a][b] = graph[b][a] = 1  # 무방향 그래프이므로 양쪽 방향에 간선 표시

# DFS와 BFS 호출
dfs(start)
print()
bfs(start)

```
<br>
<br>
<br>


## DFS와 백트래킹의 차이점
- DFS와 백트래킹은 둘다 재귀를 통해 구현하고 돌아가는 개념이 들어가있지만 DFS는 하나의 길을 끝까지 탐색한 후에 돌아오고 백트래킹은 가는 길에 답이 없다고 판단되면 돌아온다
- DFS는 그래프나 트리를 탐색하는 특정 알고리즘인 반면 백트래킹은 가능성을 탐색하고 솔루션을 찾는데 사용되는 알고리즘이다.
    - DFS는 주로 그래프나 트리 순회에 사용되어 도달가능한 모든 노드를 탐색할때 사용된다.
    - 백트래킹은 계산문제, 특히 제약 조건 만족문제에 대한 솔루션을 찾는데 사용된다.
    
<br>
<br>
<br>

## str.isdigit()
- 문자가 하나라도 있다면 False, 숫자로만 이루어져 있으면 True를 반환하는 함수
<br>
<br>
<br>

## 나누기 연산자를 사용하지 않고 나눗셈 수행하기
- 일반적인 방법은 반복문을 통해 피제수(dividend)가 제수(divisor)보다 작아질 때까지 배당금에서 제수를 빼는 것이다.
``` python
def custom_division(dividend, divisor):
    if divisor == 0:    # 피제수가 0일때 에러
        raise ValueError("Cannot divide by zero")

    result = 0
    while dividend >= divisor:
        dividend -= divisor
        result += 1

```
- 비트 시프트 연산자를 사용하는 방법도 있다
``` python
res = 0
# 비트 시프트 연산자를 사용한 나눗셈을 위한 주 루프
while dividend >= divisor:
    t, i = divisor, 1
    
    # 제수보다 작거나 같은 가장 큰 배수를 찾기 위한 내부 루프
    while dividend >= t:
        dividend -= t
        res += i
        i <<= 1  # 왼쪽 시프트 연산자를 사용하여 i를 2배로 증가시킴
        t <<= 1  # 왼쪽 시프트 연산자를 사용하여 t를 2배로 증가시킴
```
- 첫번째 방법은 코드가 간단하고 이해하기 쉽지만 단순한 반복된 덧셈을 사용하기 때문에 비트 연산자보다 속도가 느리다.
<br>
<br>
<br>

## 이진탐색 알고리즘 
- 시간 복잡도 O(log n)
- 정렬된 배열 내에서 대상의 값을 찾는 검색 알고리즘
- 목표값을 배열의 중간요소와 비교하고 이 비교를 기반으로 검색공간의 절반을 제거해나가며 목표값을 찾거나 검색공간이 비어 있을 때까지 반복한다.
``` py
def binary_search(arr, target):
    low, high = 0, len(arr) - 1     # 초기 시작과 끝값을 설정

    while low <= high:              
        mid = (low + high) // 2     # 중앙 값 설정

        if arr[mid] == target:      # 타겟이 중앙값이랑 같으면 반환
            return mid  
        elif arr[mid] < target:     # 타겟이 중앙값보다 크다면 시작값을 중앙값+1 로 변경하고 반복
            low = mid + 1  
        else:
            high = mid - 1           # 타겟이 중앙값보다 작다면 끝값을 중앙값-1 로 변경하고 반복

    return -1  
```
<br>
<br>
<br>

## 동적 프로그래밍
> 동적 프로그래밍은 복잡한 문제를 더 간단한 하위 문제로 분해하고 각 하위 문제를 한 번만 해결하여 문제를 해결하는 방법이다. 각 하위 문제의 해결책을 테이블에 저장하여 중복 계산을 피하므로 더 효율적인 해결책을 얻을 수 있다. 
<br>

- 예시 : 피보나치 수열
    - 이 예시에서는 재귀적으로 피보나치 수를 다시 계산하는 대신 중간 결과를 저장하고 재사용하여 지수적인 시간복잡도를 선형으로 줄인다.
``` py
def fibonacci(n):
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[i - 1] + fib[i - 2])
    return fib[n]

print(fibonacci(5))  # 결과: 5

'''
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2), 단 n > 1
'''
```


<br>
<br>
<br>

## 카데인 알고리즘
> 동적 프로그래밍을 적용한 방식으로 주어진 배열에서 연속된 부분 배열의 최대 합을 찾는 알고리즘이다. 각각의 최대 부분합은 이전 최대 부분합이 반영된 결과값이라는 개념을 사용한다. 릿코드 53번에서 확인할 수 있다.
<br>

- 예를 들어, nums = [1,-2,3,5,-4,2,5]라고 가정하면, 이 함수는 최대 부분 배열의 합인 11을 반환한다. 이 부분 배열은 [3,5,-4,2,5] 이다. 배열을 한 번만 순회하므로 시간 복잡도는 O(N) 이다.
``` py
def maxSubArray(nums):
    for i in range(1, len(nums)):
        if nums[i-1] > 0:
            nums[i] += nums[i-1]
    return max(nums)
```

<br>
<br>
<br>

## 편집 거리 알고리즘
> 두개의 문자열이 같아지기 위해 삽입,삭제,변경이 몇번이 이루어졌는지 최소값을 구하는 알고리즘
- EditDistance.py 참고

<br>
<br>
<br>

## 이진트리
> 트리 중에서 각 노드가 최대 2개의 자식노드를 가지는 것을 이진트리라고 한다. 자식이 없을 수도 있고 한개만 있을 수도 있다. 이때 자식노드는 각각 왼쪽 자식노드와 오른쪽 자식노드로 표현한다. 그래서 같은 루트에 같은 자식노드 하나를 가지고 있어도 자식노드의 위치가 각각 왼쪽과 오른쪽으로 다르다면 그 두 트리는 서로 다른 트리가 된다.

- 이진트리의 종류
```
1. 정 이진트리(Full Binary Tree): 모든 노드가 2개의 자식을 가지거나 자식이 없는 경우 정 이진트리라고 부른다.

2. 포화 이진트리: 모든 노드가 2개의 자식을 가지고 leaf 노드(맨 마지막 자식이 없는 말단 노드)모두 같은 레벨일때 포화 이진트리라고 부른다.

3. 완전 이진트리(Complete binary tree): 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고 마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있다. 또 노드는 왼쪽에서 오른쪽 방향으로 채워져야 한다. 어느 노드에 오른쪽 자식이 존재하면 왼쪽 자식도 존재해야 완전 이진트리이다.
```

<br>

- 이진트리 순회 방식
```
1. 전위 순회: 루트 노드를 먼저 탐색하고 자식 노드를 탐색한다.

2. 중위 순회: 왼쪽 자식 노드를 탐색하고 루트 노드를 탐색하고 오른쪽 자식 노드를 탐색한다.

3. 후위 순회: 왼쪽 자식 노드를 탐색하고 오른쪽 자식 노드를 탐색하고 루트 노드를 탐색한다.

4. 레벨 순회: 루트 노드를 탐색하고 그 다음 레벨의 노드를 순차적으로 탐색한다.
```


<br>
<br>
<br>

## 기타
- leetcode 깃허브 커밋할때 leetcode새버전으로 하면 안될수도 있다. 안되면 구버전으로 바꾸고 다시 제출하기
- 회문 문자열 : 앞에서 읽을 때나 뒤에서 읽을 때나 같은 문자열 (EX: bed,토마토 )