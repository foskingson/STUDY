# 자바로 알아보는 멀티스레드와 동시성
> 아래는 이론을 적어놓았고 자바와 함께 더 깊은 이해를 하기 위해서는 코드와 같이 보면 좋다.

<br>

## 멀티태스킹
> 2개 이상의 프로그램을 동시에 실행한다고 가정하고 CPU 코어가 1개만 있을 때 두개의 프로그램을 코어에다가 번갈아가면서 넣어 마치 동시에 실행되는 것처럼 느끼게 하는 기술이다.

<br>
<br>

## 멀티프로세싱
> 2개 이상의 CPU 코어를 이용해 여러 작업을 동시에 처리하는 기술이다.

<br>
<br>

## 프로세스와 스레드
> 프로세스는 운영체제 안에서 실행되고 있는 프로그램의 인스턴스이고 
> 스레드는 프로세스 내에서 실행되는 작업의 단위이다.

<br>

- 운영체제와 프로세스 구조 이해
```
1. 운영체제와 프로세스 관리
운영체제는 프로세스를 관리하고, 각 프로세스마다 고유한 가상 메모리 공간을 할당한다.

2. 프로세스의 가상 메모리 구조
프로세스의 가상 메모리 공간에는 여러 영역이 존재한다.
    - 코드 섹션 (Code/Text Section): 실행할 프로그램의 명령어가 저장되는 영역
    - 데이터 섹션 (Data Section): 초기화된 전역 변수 및 정적 변수가 저장되는 영역
    - 힙 (Heap): 동적 메모리 할당 영역으로, 프로세스의 모든 스레드가 접근 가능하며, 프로그램 실행 중에 크기가 변할 수 있다.
    - 스택 (Stack): 함수 호출 및 지역 변수, 리턴 주소를 저장하는 영역으로, 스레드별로 독립적으로 할당된다.

3. 스레드와 메모리
각 프로세스에는 하나 이상의 스레드가 존재한다.
스레드마다 독립적인 스택 영역을 가지고 있으며, 이는 함수 호출과 관련된 데이터를 저장한다.
힙 영역은 프로세스 내 모든 스레드가 공유한다.
```

<br>

- 이때 프로세스가 하나의 스레드만을 가진다면 단일 스레드. 여러 개라면 멀티 스레드라고 한다.
- 하나의 프로그램안에서도 동시에 여러 작업이 필요하기 때문에 멀티스레드를 사용한다.
- 스레드 간 실행 순서는 보장하지 않는다.

<br>
<br>

## 스레드와 스케줄링
> CPU 코어가 1개 있고 스레드가 여러 개라면 CPU 코어에 여러 스레드를 번갈아가면서 수행해야 한다.
> 이때 필요한 기술이 스케줄링이다.

<br>

- 운영체제는 내부에 스케줄링 큐를 가지고 있고 각각의 스레드는 스케줄링 큐에서 대기한다.
    - 이때 운영체제는 우선순위에 맞게 알아서 CPU 코어에 스레드를 할당한다.

<br>
<br>

## 스레드 생성
> 자바에서 스레드 생성은 Thread 클래스를 상속받거나 Runnable 인터페이스를 구현하는
>  방법이 있다. 이때 run()를 직접 호출하는 것이 아닌 start()를 호출해야 새로
>  생성한 스레드에서 run()이 돌아간다. 만약 main에서 바로 run()을 실행할 경우
> 메인 스레드에서 run()이 돌아간다. 

- 주로 Runnable 인터페이스를 구현하는 방식을 사용한다.
- 다만 Runnable 인터페이스의 run()를 구현할 때 체크 예외를 밖으로 못 던지기 때문에 유틸을 만들어서 사용하는게 편하다.

<br>
<br>

## 스레드의 종류
> 스레드는 사용자 스레드와 데몬 스레드 2가지 종류로 구분할 수 있다.

<br>

- 사용자 스레드 
  - 프로그램의 주요 작업을 수행한다.
  - 작업이 완료될 때까지 실행된다.
  - 모든 user 스레드가 종료되면 JVM도 종료된다.


- 데몬 스레드 
    - 백그라운드에서 보조적인 작업을 수행한다.
    - 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

<br>
<br>

## 스레드 기본 정보

1. 스레드 ID : 스레드의 고유 식별자
2. 스레드 이름 
3. 스레드 우선순위 : 1~10까지 값을 설정 가능, 기본은 5
4. 스레드 그룹 : 스레드 그룹은 스레드를 그룹화해 관리 가능
5. 스레드 상태 : 스레드의 현재 상태
   - NEW : 스레드가 아직 시작되지 않은 상태이다.
   - RUNNABLE : 스레드가 실행 중이거나 실행될 준비가 된 상태이다.
   - BLOCKED : 스레드가 동기화 락을 기다리는 상태이다.
   - WAITING : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.
   - TIMED_WAITING : 일정 시간 동안 기다리는 상태이다.
   - TERMINATED : 스레드가 실행을 마친 상태이다.

<br>
<br>

## 자바 스레드의 상태 전이 과정

1. **New → Runnable**
    - `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.

2. **Runnable → Blocked/Waiting/Timed Waiting**
    - 스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때 해당 상태로 전이된다.

3. **Blocked/Waiting/Timed Waiting → Runnable**
    - 스레드가 락을 얻거나, 기다림이 완료되면 다시 `Runnable` 상태로 돌아간다.

4. **Runnable → Terminated**
    - 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.


<br>
<br>

## 자바의 `sleep`과 `join`

### 1. `sleep()`
- **역할**: 현재 스레드를 지정된 시간만큼 멈춘다.  
- **특징**:
  - `Thread.sleep(milliseconds)`로 호출한다.
  - 지정된 시간이 지나면 스레드는 **Runnable** 상태로 돌아간다.
  - 다른 스레드에는 영향을 주지 않는다.
  - **InterruptedException**을 반드시 처리해야 한다.
- **예제**:
```java
try {
  Thread.sleep(1000); // 1초 동안 대기
} catch (InterruptedException e) {
  e.printStackTrace();
}
```

### 2. `join()`
- **역할**: 호출한 스레드가 종료될 때까지 현재 스레드가 기다린다.
- **특징**:
    - `thread.join()`으로 호출한다.
    - 멀티스레드 환경에서 특정 스레드가 작업을 완료한 후 다음 작업을 수행하도록 동기화에 사용한다.
    - `join(milliseconds)`로 호출하면 최대 지정된 시간만큼만 기다린다.
    - **InterruptedException**을 반드시 처리해야 한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  System.out.println("Thread 실행 중");
});
thread.start();

try {
  thread.join(); // thread가 종료될 때까지 대기
} catch (InterruptedException e) {
  e.printStackTrace();
}
System.out.println("Main 스레드 계속 실행");
```

<br>
<br>


## 자바의 `interrupt`와 `yield`

### 1. `interrupt()`
- **역할**: 실행 중인 스레드에 인터럽트를 발생시켜 중단 신호를 보낸다.
- **특징**:
  - `thread.interrupt()`로 호출한다.
  - 스레드가 **sleep**, **wait**, **join** 상태일 때 **InterruptedException**을 발생시킨다.
  - 실행 중인 스레드에서는 `Thread.interrupted()` 또는 `isInterrupted()`를 통해 인터럽트 상태를 확인할 수 있다.
  - 스레드가 종료되는 것은 아니며, 인터럽트를 받은 스레드가 이를 처리하는 로직을 구현해야 한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  while (!Thread.currentThread().isInterrupted()) {
      System.out.println("Running...");
      try {
          Thread.sleep(1000); // 1초 대기
      } catch (InterruptedException e) {
          System.out.println("Interrupted!");
          break; // 인터럽트를 처리하고 루프 종료
      }
  }
});
thread.start();

try {
  Thread.sleep(3000); // 3초 대기
  thread.interrupt(); // 스레드 중단 요청
} catch (InterruptedException e) {
  e.printStackTrace();
}
```

### 2. `yield()`
- **역할**: 현재 스레드가 CPU를 양보하고, 다른 스레드에게 실행 기회를 제공한다.
- **특징**:
    - `Thread.yield()`로 호출한다.
    - 스레드가 **Runnable** 상태로 전환되며, 스케줄러가 다시 스레드 실행 순서를 결정한다.
    - 반드시 실행 우선순위를 보장하지 않으며, 스레드 스케줄링 정책에 따라 동작한다.
    - CPU가 다른 스레드를 실행할지 현재 스레드를 계속 실행할지는 운영체제 스케줄러가 결정한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  for (int i = 0; i < 5; i++) {
      System.out.println("Thread 실행 중: " + i);
      Thread.yield(); // CPU 양보
  }
});
thread.start();
```



<br>
<br>


## 메모리 가시성 문제와 volatile

- 메모리 가시성 
  - 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제
  - 말 그대로 메모리에 변경한 값이 보이는가 보이지 않는가의 문제이다.
```
CPU는 처리 성능을 개선하기 위해 중간에 캐시 메모리를 사용한다. 따라서 각 스레드가 
만약 runFlag라는 예시 값을 사용한다면 먼저 캐시 메모리에 불러온다. 이후에는 
캐시 메모리에 있는 runFlag를 사용하게 된다. runFlag를 사용하는 main 스레드와 work 스레드가 있다고
가정한다면 runFlag는 각각의 캐시 메모리에 보관된다. 이때 중요한 것은 main 스레드에서
runFlag를 변경하여도 자신의 캐시 메모리에만 반영된다. 따라서 work 스레드의 캐시 메모리는
여전히 바뀌기 전의 상태이다. 이것을 메모리 가시성 문제라고 한다.
`````
- 참고로 각 CPU 코어가 독립적인 캐시 메모리를 가지고 있다
- 자세히 알아보고 싶다면 캐시 메모리의 지연 갱신과 즉시 갱신을 참고하자.
- 대부분의 현대 컴퓨터에서는 지연 갱신을 사용하고, 캐시 메모리가 메인 메모리와 동기화하는 시점은 주로 컨텍스트 스위칭이 될 때 이루어진다.

<br>

- 이러한 메모리 가시성 문제를 해결하기 위해 자바에서는 volatile이라는 키워드를 제공한다.
  - 해당 키워드를 사용하면 값을 쓸 때 모두 메인 메모리에 접근하게 된다.
  - 다만 해당 키워드를 사용하면 캐시 메모리를 사용하지 않아 성능이 느려진다.

<br>

- 또한 스레드 동기화 기법을 사용하면 메모리 가시성 문제가 발생하지 않는다.

<br>
<br>

## 자바 메모리 모델 (Java Memory Model)
>  Java Memory Model(JMM)은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티
스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다. JMM에 여러가지 내용이 있지만, 핵심은 여러 스레드들의
작업 순서를 보장하는 happens-before 관계에 대한 정의다.

<br>

- happens-before
  - happens-before 관계는 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
  - happens-before 관계는 스레드 간의 메모리 가시성을 보장하는 규칙이다.
  - happens-before 관계가 성립하면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다.
  - 즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다.
```
happens-before 관계는 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다. 만약 A 작업이 B 작업보
다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다. 즉, A 작업에서 
변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.
```
- 이러한 규칙을 추가해 개발자가 멀티스레드를 작성할 때 예상치 못한 동작을 피할 수 있다.

<br>

 