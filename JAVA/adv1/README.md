# 자바로 알아보는 멀티스레드와 동시성
> 아래는 이론을 적어놓았고 자바와 함께 더 깊은 이해를 하기 위해서는 코드와 같이 보면 좋다.

<br>

## 멀티태스킹
> 2개 이상의 프로그램을 동시에 실행한다고 가정하고 CPU 코어가 1개만 있을 때 두개의 프로그램을 코어에다가 번갈아가면서 넣어 마치 동시에 실행되는 것처럼 느끼게 하는 기술이다.

<br>
<br>

## 멀티프로세싱
> 2개 이상의 CPU 코어를 이용해 여러 작업을 동시에 처리하는 기술이다.

<br>
<br>

## 프로세스와 스레드
> 프로세스는 운영체제 안에서 실행되고 있는 프로그램의 인스턴스이고 
> 스레드는 프로세스 내에서 실행되는 작업의 단위이다.

<br>

- 운영체제와 프로세스 구조 이해
```
1. 운영체제와 프로세스 관리
운영체제는 프로세스를 관리하고, 각 프로세스마다 고유한 가상 메모리 공간을 할당한다.

2. 프로세스의 가상 메모리 구조
프로세스의 가상 메모리 공간에는 여러 영역이 존재한다.
    - 코드 섹션 (Code/Text Section): 실행할 프로그램의 명령어가 저장되는 영역
    - 데이터 섹션 (Data Section): 초기화된 전역 변수 및 정적 변수가 저장되는 영역
    - 힙 (Heap): 동적 메모리 할당 영역으로, 프로세스의 모든 스레드가 접근 가능하며, 프로그램 실행 중에 크기가 변할 수 있다.
    - 스택 (Stack): 함수 호출 및 지역 변수, 리턴 주소를 저장하는 영역으로, 스레드별로 독립적으로 할당된다.

3. 스레드와 메모리
각 프로세스에는 하나 이상의 스레드가 존재한다.
스레드마다 독립적인 스택 영역을 가지고 있으며, 이는 함수 호출과 관련된 데이터를 저장한다.
힙 영역은 프로세스 내 모든 스레드가 공유한다.
```

<br>

- 이때 프로세스가 하나의 스레드만을 가진다면 단일 스레드. 여러 개라면 멀티 스레드라고 한다.
- 하나의 프로그램안에서도 동시에 여러 작업이 필요하기 때문에 멀티스레드를 사용한다.
- 스레드 간 실행 순서는 보장하지 않는다.

<br>
<br>

## 스레드와 스케줄링
> CPU 코어가 1개 있고 스레드가 여러 개라면 CPU 코어에 여러 스레드를 번갈아가면서 수행해야 한다.
> 이때 필요한 기술이 스케줄링이다.

<br>

- 운영체제는 내부에 스케줄링 큐를 가지고 있고 각각의 스레드는 스케줄링 큐에서 대기한다.
    - 이때 운영체제는 우선순위에 맞게 알아서 CPU 코어에 스레드를 할당한다.

<br>
<br>

## 스레드 생성
> 자바에서 스레드 생성은 Thread 클래스를 상속받거나 Runnable 인터페이스를 구현하는
>  방법이 있다. 이때 run()를 직접 호출하는 것이 아닌 start()를 호출해야 새로
>  생성한 스레드에서 run()이 돌아간다. 만약 main에서 바로 run()을 실행할 경우
> 메인 스레드에서 run()이 돌아간다. 

- 주로 Runnable 인터페이스를 구현하는 방식을 사용한다.
- 다만 Runnable 인터페이스의 run()를 구현할 때 체크 예외를 밖으로 못 던지기 때문에 유틸을 만들어서 사용하는게 편하다.

<br>
<br>

## 스레드의 종류
> 스레드는 사용자 스레드와 데몬 스레드 2가지 종류로 구분할 수 있다.

<br>

- 사용자 스레드 
  - 프로그램의 주요 작업을 수행한다.
  - 작업이 완료될 때까지 실행된다.
  - 모든 user 스레드가 종료되면 JVM도 종료된다.


- 데몬 스레드 
    - 백그라운드에서 보조적인 작업을 수행한다.
    - 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.

<br>
<br>

## 스레드 기본 정보

1. 스레드 ID : 스레드의 고유 식별자
2. 스레드 이름 
3. 스레드 우선순위 : 1~10까지 값을 설정 가능, 기본은 5
4. 스레드 그룹 : 스레드 그룹은 스레드를 그룹화해 관리 가능
5. 스레드 상태 : 스레드의 현재 상태
   - NEW : 스레드가 아직 시작되지 않은 상태이다.
   - RUNNABLE : 스레드가 실행 중이거나 실행될 준비가 된 상태이다.
   - BLOCKED : 스레드가 동기화 락을 기다리는 상태이다.
   - WAITING : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.
   - TIMED_WAITING : 일정 시간 동안 기다리는 상태이다.
   - TERMINATED : 스레드가 실행을 마친 상태이다.

<br>
<br>

## 자바 스레드의 상태 전이 과정

1. **New → Runnable**
    - `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.

2. **Runnable → Blocked/Waiting/Timed Waiting**
    - 스레드가 락을 얻지 못하거나, `wait()` 또는 `sleep()` 메서드를 호출할 때 해당 상태로 전이된다.

3. **Blocked/Waiting/Timed Waiting → Runnable**
    - 스레드가 락을 얻거나, 기다림이 완료되면 다시 `Runnable` 상태로 돌아간다.

4. **Runnable → Terminated**
    - 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.


<br>
<br>

## 자바의 `sleep`과 `join`

### 1. `sleep()`
- **역할**: 현재 스레드를 지정된 시간만큼 멈춘다.  
- **특징**:
  - `Thread.sleep(milliseconds)`로 호출한다.
  - 지정된 시간이 지나면 스레드는 **Runnable** 상태로 돌아간다.
  - 다른 스레드에는 영향을 주지 않는다.
  - **InterruptedException**을 반드시 처리해야 한다.
- **예제**:
```java
try {
  Thread.sleep(1000); // 1초 동안 대기
} catch (InterruptedException e) {
  e.printStackTrace();
}
```

### 2. `join()`
- **역할**: 호출한 스레드가 종료될 때까지 현재 스레드가 기다린다.
- **특징**:
    - `thread.join()`으로 호출한다.
    - 멀티스레드 환경에서 특정 스레드가 작업을 완료한 후 다음 작업을 수행하도록 동기화에 사용한다.
    - `join(milliseconds)`로 호출하면 최대 지정된 시간만큼만 기다린다.
    - **InterruptedException**을 반드시 처리해야 한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  System.out.println("Thread 실행 중");
});
thread.start();

try {
  thread.join(); // thread가 종료될 때까지 대기
} catch (InterruptedException e) {
  e.printStackTrace();
}
System.out.println("Main 스레드 계속 실행");
```

<br>
<br>


## 자바의 `interrupt`와 `yield`

### 1. `interrupt()`
- **역할**: 실행 중인 스레드에 인터럽트를 발생시켜 중단 신호를 보낸다.
- **특징**:
  - `thread.interrupt()`로 호출한다.
  - 스레드가 **sleep**, **wait**, **join** 상태일 때 **InterruptedException**을 발생시킨다.
  - 실행 중인 스레드에서는 `Thread.interrupted()` 또는 `isInterrupted()`를 통해 인터럽트 상태를 확인할 수 있다.
  - 스레드가 종료되는 것은 아니며, 인터럽트를 받은 스레드가 이를 처리하는 로직을 구현해야 한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  while (!Thread.currentThread().isInterrupted()) {
      System.out.println("Running...");
      try {
          Thread.sleep(1000); // 1초 대기
      } catch (InterruptedException e) {
          System.out.println("Interrupted!");
          break; // 인터럽트를 처리하고 루프 종료
      }
  }
});
thread.start();

try {
  Thread.sleep(3000); // 3초 대기
  thread.interrupt(); // 스레드 중단 요청
} catch (InterruptedException e) {
  e.printStackTrace();
}
```

### 2. `yield()`
- **역할**: 현재 스레드가 CPU를 양보하고, 다른 스레드에게 실행 기회를 제공한다.
- **특징**:
    - `Thread.yield()`로 호출한다.
    - 스레드가 **Runnable** 상태로 전환되며, 스케줄러가 다시 스레드 실행 순서를 결정한다.
    - 반드시 실행 우선순위를 보장하지 않으며, 스레드 스케줄링 정책에 따라 동작한다.
    - CPU가 다른 스레드를 실행할지 현재 스레드를 계속 실행할지는 운영체제 스케줄러가 결정한다.
- **예제**:
```java
Thread thread = new Thread(() -> {
  for (int i = 0; i < 5; i++) {
      System.out.println("Thread 실행 중: " + i);
      Thread.yield(); // CPU 양보
  }
});
thread.start();
```



<br>
<br>


## 메모리 가시성 문제와 volatile

- 메모리 가시성 
  - 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제
  - 말 그대로 메모리에 변경한 값이 보이는가 보이지 않는가의 문제이다.
```
CPU는 처리 성능을 개선하기 위해 중간에 캐시 메모리를 사용한다. 따라서 각 스레드가 
만약 runFlag라는 예시 값을 사용한다면 먼저 캐시 메모리에 불러온다. 이후에는 
캐시 메모리에 있는 runFlag를 사용하게 된다. runFlag를 사용하는 main 스레드와 work 스레드가 있다고
가정한다면 runFlag는 각각의 캐시 메모리에 보관된다. 이때 중요한 것은 main 스레드에서
runFlag를 변경하여도 자신의 캐시 메모리에만 반영된다. 따라서 work 스레드의 캐시 메모리는
여전히 바뀌기 전의 상태이다. 이것을 메모리 가시성 문제라고 한다.
`````
- 참고로 각 CPU 코어가 독립적인 캐시 메모리를 가지고 있다
- 자세히 알아보고 싶다면 캐시 메모리의 지연 갱신과 즉시 갱신을 참고하자.
- 대부분의 현대 컴퓨터에서는 지연 갱신을 사용하고, 캐시 메모리가 메인 메모리와 동기화하는 시점은 주로 컨텍스트 스위칭이 될 때 이루어진다.

<br>

- 이러한 메모리 가시성 문제를 해결하기 위해 자바에서는 volatile이라는 키워드를 제공한다.
  - 해당 키워드를 사용하면 값을 쓸 때 모두 메인 메모리에 접근하게 된다.
  - 다만 해당 키워드를 사용하면 캐시 메모리를 사용하지 않아 성능이 느려진다.

<br>

- 또한 스레드 동기화 기법을 사용하면 메모리 가시성 문제가 발생하지 않는다.

<br>
<br>

## 자바 메모리 모델 (Java Memory Model)
>  Java Memory Model(JMM)은 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티
스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다. JMM에 여러가지 내용이 있지만, 핵심은 여러 스레드들의
작업 순서를 보장하는 happens-before 관계에 대한 정의다.

<br>

- happens-before
  - happens-before 관계는 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
  - happens-before 관계는 스레드 간의 메모리 가시성을 보장하는 규칙이다.
  - happens-before 관계가 성립하면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다.
  - 즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다.
```
happens-before 관계는 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다. 만약 A 작업이 B 작업보
다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다. 즉, A 작업에서 
변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.
```
- 이러한 규칙을 추가해 개발자가 멀티스레드를 작성할 때 예상치 못한 동작을 피할 수 있다.

<br>
<br>

## 동기화 synchronized
> 여러 스레드가 접근하는 자원을 공유 자원이라고 한다. 멀티스레드를 사용할 때는 이런 공유 자원에 대한 접근을 동기화 해서 동시성 문제가 발생하지 않게
> 방지하는 것이 중요하다. 쉽게 말해 동시가 아닌 순차적으로 공유자원에 접근하게 하는 것이다.

- 동시성 문제
  - 멀티스레드 환경에서 공유자원에 대해 여러 개의 스레드가 동시 접근할때 일어나는 문제이다.
  - 예를 들면 한 스레드의 검증로직을 끝내고 변경 로직을 실행하기 전에 다른 스레드의 검증로직이 실행되서 일어나는 경우가 있다.
  - volatile를 넣는다고 동시성 문제가 해결되지는 않는다.


<br>

- 임계 영역(Critical Section) : 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
  - 한 번에 하나의 스레드만 접근하도록 만들어야하는 영역으로 운영체제에서도 등장하는 용어이다.
  - 쉽게 말해 하나의 스레드가 공유자원 A에 접근하는 동안 다른 스레드가 A에 접근하지 못하도록 하는 것이다.
  - 자바에서는 `synchronized` 라는 키워드를 이용해서 임계 영역을 보호할 수 있다.
  - ex) `public synchronized boolean withdraw(int amount){...}`

<br>

- synchronized의 작동원리
  - 모든 객체(인스턴스)는 내부에 자신만의 락을 가지고 있다. 모니터 락이라고도 부른다.
  - 스레드가 synchronized 키워드의 메서드에 접근하려면 반드시 해당 인스턴스의 락이 있어야 한다.
  - 이미 하나의 스레드에 락이 주어졌다면 다른 스레드에서는 락이 없기 때문에 접근이 불가능하다.
  - 이때 락을 획득할 때까지 스레드는 BLOCKED 상태로 대기한다.
  - 락을 획득한 스레드가 메서드 수행이 완료되면 락을 반납한다.
  - 이때 락 획득 순서는 보장하지 않는다.
  - 이를 통해 메모리 가시성 문제도 해결 가능

<br>

- synchronized 코드 블럭
  - 여러 스레드가 동시에 실행하지 못하기 때문에, 병목 현상이 일어나 성능이 떨어질 수 있다. 반드시 필요한 곳에만 넣어야 한다.
  - synchronized는 메서드 단위가 아닌 코드 블럭 단위로도 설정이 가능하다.
  - 진짜 임계영역이 필요한 곳에만 해야지, 메서드 단위로 synchronized를 설정하면 성능이 떨어지기 때문에 코드 블럭 단위로 하는게 좋다.

<br>

- 이러한 동기화를 사용하면 경합 조건(Race Condition)을 방지하고 데이터 일관성을 지킬 수 있다.
  - 경합 조건 : 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제

<br>

- synchronized의 단점
  - 무한 대기 : BLOCKED 상태의 스레드는 락이 풀릴 때까지 무한 대기
  - 공정성 : 여러 스레드중 어느 스레드가 락을 획득할 지 알 수 없음, 최악의 경우 어떤 한 스레드는 오랜기간동안 락 획득 못할 수 있음

<br>

- 중요
  - 
  - 지역변수는 절대로 다른 스레드와 공유되지 않는다. => 동시성 문제 안 일어남
      -
  - 다만 지역변수를 제외한 인스턴스의 멤버변수(필드), 클래스변수는 공유될 수 있다.
      -
  - 접근하는 것 자체는 문제가 되지 않지만 중간에 값이 변하는 로직이 있다면 문제가 생기게 된다. 따라서 final을 붙이면 안전한 공유 자원이 된다.
      -

<br>
<br>

## LockSupport
> synchronized의 무한 대기 문제를 해결한 동기화 기술로 스레드를 WAITING 상태로 변경한다. 누군가 깨우기 전까지 계속 그 상태로 대기
> 하면서 CPU 실행 스케줄링에는 들어가지 않는다. 다만 이건 너무 저수준이기 때문에 아래에 있는 ReentrantLock을 주로 사용한다.

- **주요 기능**
    1. **park()**
        - 스레드를 `WAITING` 상태로 변경한다.
        - 설명: 스레드를 대기 상태로 둔다.
        - 참고: `park`의 뜻은 "주차하다", "두다"라는 의미이다.

    2. **parkNanos(nanos)**
        - 스레드를 나노초 동안만 `TIMED_WAITING` 상태로 변경한다.
        - 설명: 지정한 나노초가 지나면 `TIMED_WAITING` 상태에서 빠져나와 `RUNNABLE` 상태로 변경된다.

    3. **unpark(thread)**
        - `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경한다.
        - 설명: 대기 중인 스레드를 다시 실행 가능한 상태로 바꾼다.

<br>
<br>

## ReentrantLock
> 자바는 synchronized와 BLOCKED 상태를 통한 임계 영역 관리의 한계를 극복하기 위해
> Lock 인터페이스와 ReentrantLock 구현체를 제공한다.  특히 락을 특정 시간 만큼만 시도하거나, 인터럽트 가능한 락을 사용할 때 유용하다.


- 아래는 주요 메서드들


- **`void lock()`**
    - **주요 기능**: 락을 획득한다.
    - 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기 상태(`WAITING`)에 들어간다. 이 메서드는 인터럽트에 응답하지 않는다.
    - **예시**: 맛집에 한번 줄을 서면 끝까지 기다린다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기하지 않고 기다린다.
    - **주의**: 여기서 사용하는 락은 객체 내부에 있는 모니터 락이 아니며, `ReentrantLock`에서 제공하는 락이다.



- **`void lockInterruptibly()`**
    - **주요 기능**: 락 획득을 시도하되, 다른 스레드가 인터럽트할 수 있도록 한다.
    - 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 락을 획득할 때까지 대기한다. 대기 중에 인터럽트가 발생하면 `InterruptedException`을 발생시키며 락 획득을 포기한다.
    - **예시**: 맛집에 한번 줄을 서서 기다리지만, 친구가 다른 맛집을 찾았다고 중간에 연락하면 포기한다.


- **`boolean tryLock()`**
    - **주요 기능**: 락 획득을 시도하고, 즉시 성공 여부를 반환한다.
    - 만약 다른 스레드가 이미 락을 획득했다면 `false`를 반환하고, 그렇지 않으면 락을 획득하고 `true`를 반환한다.
    - **예시**: 맛집에 대기 줄이 없으면 바로 들어가고, 대기 줄이 있으면 즉시 포기한다.


- **`boolean tryLock(long time, TimeUnit unit)`**
    - **주요 기능**: 주어진 시간 동안 락 획득을 시도한다.
    - 주어진 시간 안에 락을 획득하면 `true`를 반환하고, 주어진 시간이 지나도 락을 획득하지 못한 경우 `false`를 반환한다.
    - 대기 중 인터럽트가 발생하면 `InterruptedException`이 발생하며 락 획득을 포기한다.
    - **예시**: 맛집에 줄을 서지만 특정 시간 만큼만 기다린다. 특정 시간이 지나도 계속 줄을 서야 한다면 포기한다. 친구가 다른 맛집을 찾았다고 중간에 연락해도 포기한다.


- **`void unlock()`**
    - **주요 기능**: 락을 해제한다.
    - 락을 해제하면 락을 획득하려고 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.
    - 락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 `IllegalMonitorStateException`이 발생할 수 있다.
    - **예시**: 식당 안에 있는 손님이 밥을 먹고 나가면 자리가 하나 나고, 기다리던 손님이 자리를 차지하게 된다.


- **`Condition newCondition()`**
    - **주요 기능**: `Condition` 객체를 생성하여 반환한다.
    - `Condition`은 스레드를 기다리게 하거나 신호를 보낼 수 있도록 한다. 이는 `Object.wait()`와 `Object.notify()`와 유사한 역할을 한다.
    - **참고**: 이 부분은 나중에 더 자세히 다룬다.

<br>

- 추가로 ReentrantLock는 스레드가 공정하게 락을 얻을 수 있도록 제공한다.
  - 비공정 모드 : 대기 중인 스레드 중 아무나 락을 획득
  - 공정 모드 : 락을 요청한 순서대로 스레드가 락을 획득, but 성능이 떨어질 수 있다.
```java
// 비공정 모드 락
private final Lock nonFairLock = new ReentrantLock();
 // 공정 모드 락
private final Lock fairLock = new ReentrantLock(true);
```

<br>
<br>

## 생산자 소비자 문제
> 멀티스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나로, 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황을 다룬다. 한정된 버퍼 문제라고도 한다.

<br>

- 문제 상황
  - 생산자가 너무 빠를 때
    - 버퍼가 가득 차서 더 이상 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성한다.
    - 버퍼가 가득 찬 경우, **생산자는 버퍼에 빈 공간이 생길 때까지 기다려야 한다.**

  - 소비자가 너무 빠를 때
    - 버퍼가 비어서 더 이상 소비할 데이터가 없을 때까지 소비자가 데이터를 처리한다.
    - 버퍼가 비어있을 경우, **소비자는 버퍼에 새로운 데이터가 들어올 때까지 기다려야 한다.**

<br>

- 해결 방법으로 wait이나 notify를 사용하는 방법이 있다. 하지만 여전히 스레드 기아라는 비효율적인 문제점이 존재한다.

<br>

- 여전히 남아있는 비효율 문제를 해결하기 위해서 `BlockingQueue`를 사용한다.

<br>
<br>

## 원자적 연산
> 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다. 쉽게 이야기 해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는
> 연산이라는 뜻이다. 이러한 원자적 연산이 아닌 경우에는 안전한 임계 영역을 만들어야 한다. 동기화를 통해서도 가능하지만 연산이 단순하고 충돌이 적은 멀티스레드 환경
> 에서는 원자적 연산 CAS연산이 성능에 도움이 된다.

<br>
<br>

## 동시성 컬렉션
> ArrayList와 같은 java.util 패키지에 소속되어 있는 컬렉션 프레임워크의 대부분의 연산은 여러 스레드가 동시에 접근했을 때 안전하지 않다. 이러한 컬렉션 프레임워크가 제공하는 연산은 원자적 연산이 아니기 때문이다.
> 따라서 자바는 java.util.concurrent 패키지에 동시성 컬렉션을 만들어 멀티스레드 환경에서도 스레드 세이프하게 해놓았다.

<br>

- **`Set` 관련**
  - `HashSet`
  - `LinkedHashSet` (입력 순서 유지)
  - `TreeSet` (정렬 지원)
  - `ConcurrentSkipListSet` (동시성 지원)
  - `CopyOnWriteArraySet`


- **`List` 관련**
  - `ArrayList`
  - `CopyOnWriteArrayList` (동시성 지원)
  - `LinkedList` (삽입/삭제 빈번 시 효율적)


- **`Map` 관련**
  - `HashMap`
  - `LinkedHashMap` (입력 순서 유지)
  - `TreeMap` (정렬 지원)
  - `ConcurrentHashMap` (동시성 지원)
  - `ConcurrentSkipListMap` (동시성 및 정렬 지원)


- **`Queue` 관련**
  - `LinkedList` (Deque를 구현한 큐)
  - **동시성 큐**
    - `ConcurrentLinkedQueue` (비 차단 동시성 큐)
    - `ConcurrentLinkedDeque` (비 차단 동시성 데크)
  - **블로킹 큐**
    - `ArrayBlockingQueue` (크기 고정, 공정 모드 지원)
    - `LinkedBlockingQueue` (크기 고정 또는 무한 가능)
    - `PriorityBlockingQueue` (우선순위 큐)
    - `SynchronousQueue` (핸드오프 메커니즘 제공)
    - `DelayQueue` (요소 지연 처리)


- **추가**
  - `Collections.synchronizedXxx()` (동기화된 컬렉션 생성)


<br>
<br>

## 스레드 풀
> 스레드를 직접 생성하게 사용하게 되면 생성 시간으로 인한 성능 문제라던가 스레드 관리 문제 등의 문제가 생기게 된다. 따라서 스레드를 관리하는 스레드 풀을 만들어
> 스레드를 필요한 만큼 미리 만들어두고 사용한다. 자바는 이러한 스레드 풀 기능을 제공하고 스레드를 효과적으로 관리하기 위해 `Executor` 라는 프레임워크를
> 제공한다.

<br>

## Executor
> 자바의 Executor 프레임워크는 멀티스레딩 및 병렬 처리를 쉽게 사용할 수 있도록 돕는 기능의 모음이다. 이 프레임워
크는 작업 실행의 관리 및 스레드 풀 관리를 효율적으로 처리해서 개발자가 직접 스레드를 생성하고 관리하는 복잡함을
줄여준다. 주로 Executor를 확장한 `ExecutorService` 인터페이스를 사용한다. 또한 Runnable 대신 `Callable`을 같이 사용하며 기존의
> 단점을 해결할 수 있다.

<br>

- Executor 스레드 풀 관리 전략
  - newSingleThreadPool() : 단일 스레드 풀 전략
    - 스레드 풀에 기본 스레드 1개만 사용한다.
    - 큐 사이즈 제한 x (LinkedBlockingQueue)
    - 간단히 사용, 테스트 용도
    
  - newFixedThreadPool(nThreads) : : 고정 스레드 풀 전략
    - 스레드 풀에 n 만큼의 기본 스레드를 생성. 초과 스레드는 생성 x
    - 큐 사이즈 제한 x (LinkedBlockingQueue)
    - 스레드 수 고정 => 안정적인 방식
    
  - newCachedThreadPool() : 캐시 스레드 풀 전략
    - 기본 스레드를 사용하지 않고, 60초 생존 주기를 가진 초과 스레드만 사용한다.
    - 초과 스레드의 수는 제한이 없다. 빠르고 유연하지만 자원을 너무 많이 사용하면 갑자기 시스템이 다운될 수 있음.
    - 큐에 작업을 저장하지 않는다. (SynchronousQueue) 대신에 생산자의 요청을 스레드 풀의 소비자 스레드가 직접 받아서 바로 처리한다.
      - 쉽게 생각해서 중간에 버퍼를 두지 않는 생산자와 소비자의 직거래
    - 모든 요청이 대기하지 않고 스레드가 바로바로 처리한다. 따라서 빠른 처리가 가능하다.
    
  - 사용자 정의 풀 전략
    - 일반적인 상황에는 고정 크기의 스레드로 서비스를 안정적으로 운영한다.
    - 갑작스럽게 요청이 폭증한 상황에는 스레드를 추가로 투입해 작업을 처리한다.
    - 요청이 폭증해 긴급 대응이 어렵다면 사용자 요청을 거절한다.
    - 큐 사이즈 제한 o (ArrayBlockingQueue)


<br>

- Executor 예외 정책
  - AbortPolicy: 작업을 요청할 때, 큐도 가득 차고 초과 스레드도 더는 할당할 수 없다면 작업을 거절한다.  
  작업을 거절하는 다양한 정책을 제공한다.

  - DiscardPolicy: 새로운 작업을 제출할 때, 큐가 가득 차면 작업을 조용히 버린다.

  - CallerRunsPolicy: 새로운 작업을 제출할 때, 작업을 제출한 스레드가 대신해서 직접 작업을 실행한다.

  - 사용자 정의: 개발자가 직접 정의한 거절 정책을 사용할 수 있다.